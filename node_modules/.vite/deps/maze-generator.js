import {
  __commonJS
} from "./chunk-Y2F7D3TJ.js";

// node_modules/maze-generator/index.js
var require_maze_generator = __commonJS({
  "node_modules/maze-generator/index.js"(exports, module) {
    module.exports = function(size, algorithm) {
      "use strict";
      var width = size[0], height = size[1], generator = {};
      algorithm = algorithm || "recursiveBacktracking";
      function shuffle(o) {
        for (var j, x, i = o.length; i; j = Math.floor(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x)
          return o;
      }
      generator.recursiveBacktracking = function() {
        var grid = [], h = height;
        while (h--) {
          var cells = [], w = width;
          while (w--)
            cells.push(0);
          grid.push(cells);
        }
        var N = 1, S = 2, E = 4, W = 8, dirs = ["N", "E", "S", "W"], dirsValue = { N, E, S, W }, DX = { E: 1, W: -1, N: 0, S: 0 }, DY = { E: 0, W: 0, N: -1, S: 1 }, OPPOSITE = { E: W, W: E, N: S, S: N };
        function carve_passages_from(cx, cy, grid2) {
          var directions = shuffle(dirs);
          setImmediate(function() {
            directions.forEach(function(direction) {
              var nx = cx + DX[direction], ny = cy + DY[direction];
              if (ny >= 0 && ny <= grid2.length - 1 && nx >= 0 && nx <= grid2.length - 1 && grid2[ny][nx] === 0) {
                grid2[cy][cx] += dirsValue[direction];
                grid2[ny][nx] += OPPOSITE[direction];
                carve_passages_from(nx, ny, grid2);
              }
            });
          });
        }
        carve_passages_from(0, 0, grid);
        return grid;
      };
      if (typeof generator[algorithm] !== "undefined") {
        return generator[algorithm]();
      } else {
        throw new Error('maze-generator Error: Algorithm "' + algorithm + '" does not exist');
      }
    };
  }
});
export default require_maze_generator();
//# sourceMappingURL=maze-generator.js.map
