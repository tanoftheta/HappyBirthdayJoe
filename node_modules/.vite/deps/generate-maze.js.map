{
  "version": 3,
  "sources": ["../../generate-maze/src/generate-maze.ts"],
  "sourcesContent": ["type Cell = {\n  x: number,\n  y: number,\n  top: boolean,\n  left: boolean,\n  bottom: boolean,\n  right: boolean,\n  set: number,\n}\n\nfunction compact<T>(array: T[]): T[] {\n  return array.filter(Boolean);\n}\nfunction difference<T>(c: T[], d: T[]): T[] {\n  return [c, d].reduce((a, b) => a.filter(c => !b.includes(c)));\n}\nfunction initial<T>(array: T[]): T[] {\n  return array.slice(0, -1);\n}\nfunction groupBy<T>(list: T[], key: string): { [key: string]: T[] } {\n  const keys = list.map(item => item[key]);\n  let dict = uniq(keys).reduce((prev, next) => {\n    return {\n      ...prev,\n      [next]: []\n    }\n  }, {});\n\n  list.forEach(item => dict[item[key]].push(item));\n\n  return dict;\n}\nfunction last<T>(array: T[]): T {\n  return array[array.length - 1];\n}\nfunction range(n: number, end = 0): number[] {\n  return end ? Array.from(Array(end - n).keys()).map(k => k + n) : Array.from(Array(n).keys());\n}\nfunction uniq<T>(array: T[]): T[] {\n  return [...new Set(array)];\n}\nfunction sampleSize<T>(array: T[], n: number, random: () => number) {\n  n = n == null ? 1 : n;\n  const length = array == null ? 0 : array.length;\n  if (!length || n < 1) {\n    return [];\n  }\n  n = n > length ? length : n;\n  let index = -1;\n  const lastIndex = length - 1;\n  const result = [...array];\n  while (++index < n) {\n    const rand = index + Math.floor(random() * (lastIndex - index + 1));\n    const value = result[rand];\n    result[rand] = result[index];\n    result[index] = value;\n  }\n  return result.slice(0, n);\n}\n\nfunction mulberry32(seed: number) {\n  return function () {\n    let t = seed += 0x6D2B79F5;\n    t = Math.imul(t ^ t >>> 15, t | 1);\n    t ^= t + Math.imul(t ^ t >>> 7, t | 61);\n    return ((t ^ t >>> 14) >>> 0) / 4294967296;\n  }\n}\n\nfunction mergeSetWith(row: Cell[], oldSet: number, newSet: number) {\n  row.forEach(box => {\n    if (box.set === oldSet) box.set = newSet;\n  });\n}\n\nfunction populateMissingSets(row: Cell[], random: () => number) {\n  const setsInUse = compact(uniq(row.map(row => row.set)));\n  const allSets = range(1, row.length + 1);\n  const availableSets = difference(allSets, setsInUse).sort(() => 0.5 - random());\n  row.filter(box => !box.set).forEach((box, i) => box.set = availableSets[i]);\n}\n\nfunction mergeRandomSetsIn(row: Cell[], random: () => number, probability = 0.5) {\n  // Randomly merge some disjoint sets\n  const allBoxesButLast = initial(row);\n  allBoxesButLast.forEach((current, x) => {\n    const next = row[x + 1];\n    const differentSets = current.set !== next.set;\n    const shouldMerge = random() <= probability;\n    if (differentSets && shouldMerge) {\n      mergeSetWith(row, next.set, current.set);\n      current.right = false;\n      next.left = false;\n    }\n  });\n}\n\nfunction addSetExits(row: Cell[], nextRow: Cell[], random: () => number) {\n  // Randomly add bottom exit for each set\n  const setsInRow = Object.values(groupBy(row, 'set'));\n  const { ceil } = Math;\n  setsInRow.forEach(set => {\n    const exits = sampleSize(set, ceil(random() * set.length), random);\n    exits.forEach(exit => {\n      if (exit) {\n        const below = nextRow[exit.x];\n        exit.bottom = false;\n        below.top = false;\n        below.set = exit.set;\n      }\n    });\n  });\n}\n\nfunction generate(width = 8, height = width, closed = true, seed = 1) {\n  const random = mulberry32(seed);\n  const maze = [];\n  const r = range(width);\n\n  // Populate maze with empty cells:\n  for (let y = 0; y < height; y += 1) {\n    const row = r.map(x => {\n      return {\n        x,\n        y,\n        top: closed || y > 0,\n        left: closed || x > 0,\n        bottom: closed || y < (height - 1),\n        right: closed || x < (width - 1)\n      };\n    });\n    maze.push(row);\n  }\n\n  // All rows except last:\n  initial(maze).forEach((row, y) => { // TODO initial temp?\n    populateMissingSets(row, random);\n    mergeRandomSetsIn(row, random);\n    addSetExits(row, maze[y + 1], random);\n  });\n\n  const lastRow = last(maze);\n  populateMissingSets(lastRow, random);\n  mergeRandomSetsIn(lastRow, random, 1);\n\n  return maze;\n}\n\nexport default generate;\n"],
  "mappings": "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",
  "names": ["initial", "array", "slice", "range", "n", "end", "Array", "from", "keys", "map", "k", "uniq", "Set", "populateMissingSets", "row", "random", "setsInUse", "set", "filter", "Boolean", "availableSets", "c", "length", "d", "reduce", "a", "b", "includes", "sort", "box", "forEach", "i", "mergeRandomSetsIn", "probability", "current", "x", "next", "differentSets", "shouldMerge", "oldSet", "newSet", "right", "left", "generate", "width", "height", "closed", "seed", "t", "Math", "imul", "maze", "r", "y", "top", "bottom", "push", "nextRow", "setsInRow", "Object", "values", "list", "key", "dict", "item", "prev", "ceil", "index", "lastIndex", "result", "rand", "floor", "value", "exit", "below", "lastRow"]
}
